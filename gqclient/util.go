package gqclient

import (
	"crypto/rand"
	"math/big"
	prand "math/rand"
)

// BtoInt converts a byte slice into int in Big Endian order
// Uint methods from binary package can be used, but they are messy
func BtoInt(b []byte) int {
	var mult uint = 1
	var sum uint
	length := uint(len(b))
	var i uint
	for i = 0; i < length; i++ {
		sum += uint(b[i]) * (mult << ((length - i - 1) * 8))
	}
	return int(sum)
}

// CryptoRandBytes generates a byte slice filled with cryptographically secure random bytes
func CryptoRandBytes(length int) (ret []byte) {
	byteMax := big.NewInt(int64(256))
	for len(ret) < length {
		randInt, _ := rand.Int(rand.Reader, byteMax)
		randByte := byte(randInt.Int64())
		ret = append(ret, randByte)
	}
	return
}

// PsudoRandBytes returns a byte slice filled with psudorandom bytes generated by the seed
func PsudoRandBytes(length int, seed int64) (ret []byte) {
	prand.Seed(seed)
	for len(ret) < length {
		randByte := byte(prand.Intn(256))
		ret = append(ret, randByte)
	}
	return
}
